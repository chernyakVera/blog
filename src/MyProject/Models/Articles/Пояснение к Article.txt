/**Преобразовали класс со статьями в класс,
 * работающий как таблица article из БД
 * (пишем свою ORM)
 * и далее каждый созданный объект этого класса
 * будет соответствовать одной строке из таблицы article из БД
 */

/**свойство $authorId будет соответствовать
     * столбцу author_id из таблицы article и т.д.
     */




public function getAuthor(): User
    /** Метод, возвращающий, благодаря статическому методу getById
     * класса User (унаследовавшего ее от ActiveRecordEntity),
     * одну строку  из таблицы `users` (за это отвечает статический метод getTableName)
     * по переданному id ($this->authorId), изъятому из пришедщего массива
     * по методу authorId.
     * Т.е. на выходе получаю по-прежнему одну строку по нужному id,
     * но теперь эта строка (в виде массива) явл. объектом класса User.
     */




protected static function getTableName(): string
/** Mетод, возвращающий
* имя таблицы `articles`, т.к. мы находимся в классе Article,
* который отражает таблицу `articles` из БД.
+ он реализован из-за того, что класс Article явл. 
наследником класса ActiveRecordEntity */




public function setName(string $name)
/** Сеттер(метод, где можно задать новое значение вместо уже существующего)
     * для столбца name.
     */






public function setAuthor(User $author)
/** Сеттер для автора, принимает объект класса User */


        /* Здесь свойству класса Article authorId присваиваем значение (цифру),
        выданное вызванным методом getId() объекта класса User $author.

        Мало что понятно - сетер обращается к геттеру? А зачем тогда записывать
        в аргумент сеттера id? */




public static function createFromArray(array $fields, User $author) : Article
/** Метод для фактического создания статьи (ловля ошибок, распределение данных
     * и отправка в БД)
     */


        /* Создаем обект класса Article,т.к. будущая статья должна
        быть объектом этого класса*/

  	/* Через сеттеры задаем автора, название и текст статьи и далее,
        с помощью метода save(), отправляем новую статью в БД. */







public function updateFromArray(array $fields): Article
 /** Метод для редактирования статей */


	/* Проверка на пустоту переданных данных
        (но пустыми они просто не могут быть, т.к.
        будет передан или новый текст/название, если не пустой, или существующий
        текст/название статьи) */

	/* Если ошибок не было обнаружено, то задаем через сеттеры новое
        название и текст статьи.
        Далее, с помощью метода save() отправляем статью в БД.
         */

	/* Результатом метода будет отредактированная статья - массив, кот.
        явл. объектом класса Article. */








