/** Используем именно абстрактный класс, т.к. нам не нужны экземпляры от него.
 * Интересует только наследование для классов Article и User.
 */


    /** Т.к. у обеих таблиц есть id, то просто напишем это свойство
     *и геттер один раз и потом унаследуемся
     */


public function __set($name, $value)
/** магический метод __set будет выполнен при записи данных в недоступные свойства*/




private function underscoreToCamelCase(string $sourse): string
/**В этом методе преобразуем виды строк (названия столбцов из БД)
     * snake_case в camelCase,
     * благодаря функ ucwords(upper case words) - преобразует в верхний
     * регистр первый символ каждого слова в строке - и благдаря
     * функ str_replace - заменяет все вхождения строки поиска на строку замены,
     * а также благодаря функ lcfirst (lower case first) - преобразует первый символ
     * строки в нижний регистр
     */





public static function findAll(): array
    /**Статический метод, при вызове которого вернуться все статьи из таблицы
     * `articles` из БД.
     * Используем именно статический метод, чтобы не создавать объект класса Article,
     * а просто и быстро сразу получать все статьи.
     */


        /** передавая аргументы в метод query, на позиции className
         * передаем static::class - это наз. поздним связыванием и означает,
         * что данный статический метод будет складывать данные (от запроса в БД)
         * в класс, в котором вызывается, а не в котором определен
         * (определен только в классе Article, но будет без проблем работать
         *  и для класса MainController)
         */






abstract protected static function getTableName(): string;
/** Абстрактный метод, обязывающий наследников описать его у себя.
     *  Так, класс Article будет возвращать название таблицы `articles`
     */





public static function getById(int $id): ?self
    /** Статический метод, который возвращает строку таблицы
     * (а вот какой таблицы - за это отвечает ранее описанный
     * статический абстрактный метод getTableName(), который вызывается
     * в sql запросе при склеивании строки запроса)
     * по переданному в строке адреса id.
     */

	* этот метод возвращает одну строку по id, используя sql запрос,
         * а если вернуть нечего, то null.




private function camelCaseToUnderscore(string $source): string
/** Метод, преобразующий заголовки столбцов ORM в заголовки столбцов БД,
     * т.е. из camelCase в snake_case.
     * Функ. preg_replace принимает регулярное выражение,  строку замены и саму строку,
     * в которой надо искать совпадения по регулярке и заменять на '_'.
     * Далее функ. strtolower преобразует строку в нижний регистр.
     */



private function mapPropertiesToDbFormat(): array
/** Метод, возвращающий массив вида ['название_свойства1' => значение свойства1,
     * 'название_свойства2' => значение свойства2]. Используем рефлексию.
     */


        /* Создала объект класса рефлектора и поместила как аргумент объект $this,
        т.е. любой объект, который вызовет этот метод mapPropertiesToDbFormat() */

        /* Достала из объекта $reflector(тут массив) класса рефлектора
        ReflectionObject свойства с помощью метода класса getProperties()
        и сложила результат (массив) в переменную $properties*/

 	/* Инициировала пустой массив для складывания в него результата в будущем */

	
	/* Перебираю массив $properties - свойства переданного ранее объекта */

            /* Достала имя текущей части массива с помощью метода getName(),
            который явл. методом класса ReflectionObject */

            /* Непонятно зачем использовать $this, когда и так уже есть $propertyName.
            Здесь, пользуясь методом camelCaseToUnderscore(), преобразуем формат названия
            свойств массива (они же названия столбцов таблицы БД) из camelCase в snake_case. *


            /* Снова что-то непонятное происходит здесь $this->$propertyName:
            вызвать текущий объект $this и вызвать у него свойство $propertyName?
            Это имя сейчас будет в camelCase. Т.е. мы присваиваем в массив
            ['преобразованное_имя_столбца/свойства' => староеИмяСтолбца/Свойства]? */




public function save()
/** Метод, который будет сохранять новое состояние
     * объекта в БД.
     */


            /* если id статьи не равен нулю, т.е. такая статья/пользователь
             существует, то вызываем метод обновления update() */


            /* если id равен null, т.е. такой статьи/пользователя
            не сущестует, то будет вызван метод insert(),
            создающий новую запись в таблице. */



private function update(array $mappedProperties): void
   /** Метод для обновления записей в БД.
     * Запрос Update выглядит так:
     * UPDATE table_name
     * SET column1 = :param1, column2 = :param2, ...
     * WHERE condition;
     * Сейчас сюда пришел массив вида ['column1' => value1,
     * 'column2' => value2].
     * Его надо разделить на 2 массива:
     * первый вида 'column1' = :param1,
     * второй вида :param1 = value1.
     * Данный метод вызывается методом save(), см.выше.
     */


        /* Инициализация 2 массивов */
        /* Инициализация счетчика для нумерации column и :param */


        /* Перебираем переданный массив, как столбец и значение */

            /* Параметром будет строка ':param' склеенная со значением счетчика */


            /* В массив вида 'column1' = :param1 записываем переменную $column,
            отвечающую за имя столбца (получили ее при расщеплении массива
            на составляющие при помощи foreach) и приравниваем к ранее полученной
            переменной $param. */

            /* А в массив вида :param1 = value1 присваиваем по ключу $param (переменная,
            полученная ранее) значение $value (полученное благодаря расщеплению
            массива на составляющие с помощью foreach). */

            /* Увеличиваем счетчик на 1 */


	/* Составляем запрос согласно синтаксису SQL */

        /* Создаем объект класса singletone Db() */

        /* Отправляем запрос на выполнение с помощью метода query(),
        принимающего составленный SQL запрос $sql,
        параметры запроса и класс, объектом которого в итоге будет результат. */





private function insert(array $mappedProperties): void
   /** Метод для добаления новых записей в БД.
     * Запрос на добавление выглядит так:
     * INSERT INTO table_name ($column1, $column2)
     * VALUES (:column1, :column2)
     * И затем нудно будет передать массив с параметрами типа:
     * [':column1' => value1, ':column2' => value2]
     * Такая запись ':column' - это про защиту от SQL-инъекций?
     */



        /* С помощью функ. array_filter() убрали из массива значения с null. */


        /* В запрос отправляем не классическое
        INSERT INTO table_name(column1, column2)
        VALUES(value1, value2),
        а защищенный от sql-инъекций запрос (через подстановку параметров):
        INSERT INTO table_name(column1, column2)
        VALUES(:column1, :column2);
        И уже потом, в query() указываем необходимые параметры,
        содержащие связь [параметр = значение] массив $params2values. */

        /* Создаем объект класса singleton Db, чтобы потом воспользоваться
        его методом query() */

        /* Здесь обращаемся к собственному свойству id
        (свойство класса ActiveRecordEntity) и присваиваем ему, будто в конструкторе,
        значение, полученное после вызова метода getLastId, которое в данном случае
        вернет значение id только что созданной новой строки в таблице БД */





private function refresh()

        /* Получаю объект(строку из таблицы) из БД с нужным id.
        Запись static::getById() - это вызов метода getById()
        текущего класса (static - Article или User).
        Далее в метод getById() передаю как аргумент значение id текущего
        объекта (строки из таблицы БД)*/

        /* А здесь просто перебираю полученные данные из $objectFromDb,
        разделяя их на название столбца $column и значение в нем $value
        (строка-то все равно одна) и далее беру текущий объект $this
         и присваиваю его столбцу $column значение $value
         из рассматриваемой строки БД. */




public function delete()
/** Метод для удаления статей/пользователей по id. */


        /* Тут получаю id текущего объекта(строки с данными статьи
        таблицы articles из БД) */


        /* Формирую SQL запрос на удаление:
        DELETE FROM table_name
        WHERE condition = :conditionParam */


        /* Создаю объект класса Db, чтобы далее воспользоваться
        методом класса query(), куда передаю, сформированный ранее,
        sql запрос и параметр, который нужно подставить в условие WHERE
         [':id' => $currentId], 3м аргументом идет класс, но я его не передаю,
        т.к. мы же удаляем строку из таблицы, а не создаем объект класса.
        Класс, получается, не нужен.*/


        /* Присваиваем текущему id объекта значение null,
         т.к. мы только что удалили всю строку с текущим id и ее больше
        не существует.
        (Попробовала удалить, а потом добавить статью без обнуления текущего
        id - разницы не обнаружила.)*/





public static function findOneByColumn(string $columnName, $value): ?self
/** Метод для поиска дубликатов в таблице users БД.
     Принимает на вход название столбца и само значение в этом столбце,
     которое мы и проверяем на дубликат.
     Обращаемся к объекту БД, вызываем его метод query, передавая аргументы:
     SQL-запрос типа 'SELECT * FROM `table_name`
     * WHERE `column_name` = :value(это параметр) LIMIT 1;',
     * далее передам параметры для защиты от sql-инъекций ':value' => $value,
     * затем передаем имя класса, которому в итоге будет принадлежать результат.
     */



        /* Проверка на пустоту, но без выбрасывания исключений */
























